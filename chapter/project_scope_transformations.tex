\chapter{Project Scope Transformations}\label{project_scope_transformations}
Up until this point COOP is already able to process simple test software consisting of a single source file (e.g. c/cpp) and whatever files it may include. When using the LibTooling suite we will actually create a \textit{Tool} instance, that comprises elements of the Clang compiler front-end. To obtain the ASTs we depend on through out our entire process we feed the source files to that Tool instance. It includes a preprocessor that will resolve an preprocessor directives. This means, that any include files will be correctly treated as parts of the compilation unit. This way we can think of the resulting ASTs as representations of the to-be object files.\\
Tings get tricky however as soon as we actually start to try operating on multiple files. The \textit{Tool} instance is perfectly able to sequentially process different source files and will produce ASTs for each of them. So while we are not necessarily facing any exceptions we will at this point at least run into strange and faulty behavior. We want and need to operate on project scope. Our entire optimization strategy depends on knowing what records and fields there are, as well as every single usage of them throughout our source files respectively.\\
The LibTooling suite is intended to perform modular source-to-source transformations, for example automated style checks/improvements. This works because while those tools can be given multiple source files, ther transformation criteria will never depend on shared state between the created ASTs. In terms of optimizations we effectively want to perform a link time optimization, so we can operate on the entirety of our target project's code.\\\\
Creating an AST for each translation unit will hurt us in terms of multiply defined AST nodes. For example when our project defines a \textit{Foo.hpp} file, that contains the class definition of class \textit{Foo} and we have two source files \textit{Foo.cpp} and \textit{main.cpp} both including \textit{Foo.hpp} we will already have multiple AST nodes for our Foo's class definition in our context, as well as all the AST nodes representing method and field declarations. We wouldn't care if our transformation criteria was modular, however searching the ASTs for record definitions will now yield two class definitions and without further clarification our routine will treat them separately as they are distinct AST nodes. This applies to virtually every type of AST node.\\
Also e.g. functions and methods might associate AST nodes that will be declared in their AST context, however their respective definitions could (and will often times) exist in an entirely other translation unit.\\\\
Source transformations are also affected, since Clang's \textit{Rewriter} utility class will not be able to behave correctly when operating on distinct AST nodes pointing to the same physical file. It wont necessarily break but if changes coming from different Rewriter instances affect overlapping segments of the source file strange things will happen (or no changes might be done at all). Not to mention applying the same (redundant) changes coming from seemingly different AST nodes to the same physical file segments.\\\\
